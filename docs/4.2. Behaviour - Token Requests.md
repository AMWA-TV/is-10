# Behaviour: Tokens Requests

_(c) AMWA 2019, CC Attribution-ShareAlike 4.0 International (CC BY-SA 4.0)_

## Grants

The implicit grant MUST NOT be used as it has been deprecated in Section 3.1.2. of the [OAuth 2.0 Best Common
Practice][oauth-bcp-13] guidelines.

The password grant SHOULD NOT be used as it has been deprecated in Section 3.4. of the [OAuth 2.0 Best Common
Practice][oauth-bcp-13] guidelines.

The client credentials grant MUST NOT be used as it provides the lowest form of protection and is reserved for
applications accessing their own resources.

The Authorization Code Grant MUST be supported by the Authorization Server, and SHOULD act as the primary grant flow.
When used with Public Clients, this grant MUST be used alongside PKCE as outlined in [RFC 7636][RFC-7636], in-keeping
with the recommendations given in 3.1.1. of the [OAuth 2.0 Best Common Practice][oauth-bcp-13]. When using PKCE,
clients MUST support and prefer the "S256" `code_challenge_method`.

The Refresh Token Grant MUST be supported in order to ease the refreshing of access tokens and reduce the number user
authorization requests.

It is RECOMMENDED that Section 5 of [RFC 6819][RFC-6819], OAuth 2.0 Threat Model and Security Considerations, be
followed as closely as possible to minimise chance of a security breach, such as the leaking or hijacking of client
credentials, Authorization Codes or Refresh Tokens.

## Authorization Request and Response
_Found at the `/authorize` endpoint in the example implementation_

Successful authorization requests for the Authorization Code Grant SHALL be provided by registered clients as
defined in [RFC 6749][RFC-6749] Section 4.1.1.

The means by which the Authorization Server validates the end-user is beyond the scope of this specification, but may
include the use of a login prompt and session cookies, or integration with a corporate Single-Sign-On (SSO) System. The
authorization endpoint MUST provide means for the user to provide authorization (such as via a Web GUI), and therefore
using a HTTP Authorization mechanism to by-pass the authorization step SHOULD NOT be permitted.

A successful authorization response SHALL be serviced by the Authorization Server as defined in [RFC 6749][RFC-6749]
Section 4.1.2. The use of the STATE parameter SHOULD be used and is capable of providing per-request customization.
Support for the PKCE `code_challenge` parameter MUST be implemented as outlined in [RFC 7636][RFC-7636] for public
clients. A `code_challenge_method` parameter MUST be used alongside the `code_challenge` parameter and SHOULD be equal
to "S256" unless the client is unable to perform a SHA256 hash, in which case a value of "plain" MAY be used.

## Access Token Request and Response
_Found at the `/token` endpoint in the example implementation_

Access token requests SHALL be provided by clients as defined in [RFC 6749][RFC-6749] Section 4 based on the OAuth
2.0 grant being used.

For Public Clients, the additional parameter of `code_verifier` is added to the request, as outlined in Section 4.5 of
[RFC 7636][RFC-7636] to prevent authentication code hijacking.

Successful access token responses SHALL be serviced by the Authorization Server as defined in [RFC 6749][RFC-6749]
Section 5.1. Additionally the `expires_in` and `refresh_token` fields MUST be included in the response.

## Refresh Tokens

A refresh token is a string representing the authorization granted to the client by the resource owner. Refresh
tokens are issued to the client by the authorization server and are used to obtain a new access token when the current
access token becomes invalid or expires, in accordance with Section 1.5 of [RFC 6749][RFC-6749]. The process of
refreshing an access token is outlined in Section 6 of [RFC 6749][RFC-6749].

Authorization Servers MUST issue refresh tokens in the Bearer token returned after the completion of an authentication
flow. Each refresh token SHOULD be time-limited.

Refresh Tokens MUST be bound to a specific client, and this binding MUST be checked during token refresh.

Refresh Tokens SHOULD be rotated by the Authorization Server when clients make new token requests, as recommended by
[RFC 6819][RFC-6819]. Authorization Servers MAY continue to issue refresh tokens indefinitely without requiring users
to re-authenticate, provided the refresh token is not explicitly revoked or has expired.

In the case of Browser-Based Clients, when issuing a rotated refresh token, the Refresh Token MUST be time-limited and
the Authorization Server MUST NOT extend the lifetime of the new refresh token beyond the lifetime of the initial
refresh token, as stated in Section 8 of [OAuth 2.0 for Browser-Based Apps].

## Token Revocation
_Found at the `/revoke` endpoint in the example implementation_

Access Tokens and Refresh Tokens SHALL be revoked by the Authorization Server as defined by [RFC 7009][RFC-7009].

OAuth 2.0 clients SHALL revoke any valid refresh tokens using the revocation endpoint upon a user ceasing to require
authorization. This may be, for example, due to logging out of an application, a change of user identity or uninstalling
a given application.


[RFC-6749]: https://tools.ietf.org/html/rfc6749 "The OAuth 2.0 Authorization Framework"

[RFC-6819]: https://tools.ietf.org/html/rfc6819 "OAuth 2.0 Threat Model and Security Considerations"

[RFC-7009]: https://tools.ietf.org/html/rfc7009 "OAuth 2.0 Token Revocation"

[RFC-7636]: https://tools.ietf.org/html/rfc7636 "Proof Key for Code Exchange by OAuth Public Clients"

[RFC-8628]: https://tools.ietf.org/html/rfc8628 "OAuth 2.0 Device Authorization Grant"

[oauth-bcp-13]: https://tools.ietf.org/html/draft-ietf-oauth-security-topics-13 "OAuth 2.0 Security Best Current Practice 13"

[OAuth 2.0 for Browser-Based Apps]: https://datatracker.ietf.org/doc/draft-ietf-oauth-browser-based-apps
